1. 在`stl`中提供了许多的泛型算法 
2. 在`stl`中 函数接受的迭代器区间均是左闭右开的  这样 右区间端点 - 左区间端点 即为区间中元素个数 也为区间的实际长度 或者使用`distance()`函数 它会返回[ )区间中元素的个数 即区间长度
3. 在使用一些`stl`算法时，要注意其使用的条件 返回值 比如 区间合并函数 `merge()` 操作的两个容器要有序，第五个参数是写入位置的迭代器 必须保证容器有相应的长度 而且 它的返回值是指向有效数字的下一个 左闭右开 由此 便于我们确定结果区间的有效长度
4. 比如 一些集合操作 `set_union` `set_intersection` 它们都要求集合是有序的 而且结果也是有序的 会返回指向有效数字的下一个迭代器 便于我们确定结果区间的有效长度
5. char 和 string 的相互转换 一般是使用 `+`来拼接 一个字符串 和 一个 字符 但注意的是 `+` 两面必须有一个string的变量 否则 结果可能比较奇怪 一般地 `to_string()` 可以很好地将`int` `long long` 装换位字符串 别的类型效果不是很好 `stoll(string,nullptr,10/16`) 这个函数 可以将数值型字符串 10 或 16 进制 转换为`long long` 值
6. 许多泛型算法 接受谓词参数 ，二元谓词即参数有两个的谓词 `p1` 即表示一元参数 比如常见的有 `sort(p2) max_element(p2) accmulate(p2) find(p1) find_if(p1) any_of(p1) count(基于 == 比较) count_if(p1 基于谓词比较) lower_bound(大于等于第一个) upper_bound( 大于 的第一个) equal_range()- 返回一个pair对象 ` 谓词 可以以`lambda`表达式的形式给出 `[捕获列表] (参数) {return ...}` 其中 捕获列表用于访问局部变量 函数体基于语义 比如 sort() 传入的表达式 就是`<`运算符成立的条件 find count 就是该元素满足的条件 
参数类型 就是容器元素类型 accmulate 就是a 和 b 如何进行运算 默认是 a `+` b max_element 也是`<`成立的条件
7. 逆序可以用`greater<容器元素类型>() + 重载大于号 ` 默认是`less + 重载小于号` reverse() 反迭代器 在重载时写入相反的条件
8. map,set,priority_queue 不支持(size) 初始化 而且  其插入函数的返回值是一个pair对象 first是指向插入元素的迭代器，second 是bool 表示插入的成功与否 而顺序容器是返回指向插入元素的第一个的迭代器   它们的erase函数就会返回指向下一个元素的迭代器。
9. 泛型算法 无法改变容器的大小 只能用成员函数erase (list)除外   
10. 迭代器是指向元素的 对其解引用可以获得元素值
11. 若用迭代器遍历容器时，若使用了`erase(it)` 方法删除元素 一定要令 `i = erase(i) ` 因为删除了i指向的元素 i 就失效了 若再用`i++` 来移动 程序便会崩溃 将erase 返回值赋给i，使得`i`持续有效 此时 `i`指向被删元素的下一个元素  对所有容器均适用 
12. 当顺序容器删除元素时，由于容器会移动 故被删元素后面的迭代器会失效 故 不应保存指向顺序容器的迭代器 同时 顺序容器 我们一般也只用下标访问 只有删除时，才会用到迭代器
13. 非顺序容器 如 `list map set ` 在删除元素后，对应元素的迭代器会失效，但指向其它元素的迭代器任然持久有效 因此 可以 使用insert 函数插入元素时，存储元素对应的迭代器 即返回值的first的成员 实现迅速的删除 修改元素 
14. 非顺序容器（包括 list）迭代器不支持+1 +2 支持++ -- 可以使用`next(it,dis)` 即可获得在i后面距离为dis元素的迭代器 dis 默认是 1
15. map set list string 均有自己的成员函数 这些成员函数的效率 要比 普通泛型函数效率高
16. string 拥有两个版本的成员函数 比如 find() 第一个参数是查找的字符，第二个参数是查找的起始位置- 是个int值 查找成功 返回下标 查找失败 返回 `string::npos` 而其余所有容器的find函数 查找不成功 返回尾迭代器 而且 前两个参数要指定查找区间  同时 int 版本的erase 若只给一个参数 即删除起点 那从起点开始的字符均会被删除  substr() 用于截取字串 第一个参数为起点 第二个参数为lenth 即子串长度 第二个参数省略 即返回从起点的全部字符 
17. map set 由于键是有序的 所以提供了高效的成员函数 find(k) count(k) lower_bound(k) 这些函数均只有一个参数 即为 键 的值 相比泛型算法 省去了指定区间 erase(k) 删去键位k的元素 不过 建议erase函数 还是使用迭代器版本(单迭代器 或 迭代区间)
18. stringstreeam 可以有效地用特定字符分割字符串 默认是空格 若用别的字符 可使用`while (getline(ss,str,'#'))` 一定要循环读 若用空格 也可以 `while (ss >> str)` 先整行读入 用带分割地字符串初始化stringstream对象 再用stringstream对象读入即可
19. 插入 删除 操作多的话 可以考虑使用链表 由于链表地内存不连续 故链表无法直接使用泛型函数 但链表自身集成了一定的成员函数 比如 `sort() merge() remove unique reverse` 当然 `list` 作为双端链表 支持 `push_back front pop_back pop_front insert(it_pos,val) 返回指向插入元素的迭代器 erase(it) 返回指向删除元素下一个元素的迭代器 `